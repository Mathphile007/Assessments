# -*- coding: utf-8 -*-
"""LVADSUSR_192_IA2_RF.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1U0gjCwrPnmczD__xsQBfavP9ucX8LhTj
"""

from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score,precision_score, f1_score, recall_score, confusion_matrix
from sklearn.preprocessing import MinMaxScaler
from sklearn.preprocessing import LabelEncoder
from sklearn.ensemble import RandomForestClassifier
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt

#1.Load the dataset
df=pd.read_csv("/content/winequality-red.csv")

df.head(10)

df.info()

df.describe()

#A.Handle missing values
df.isna().sum()
#Lets see the distribution each column with missing values and replace them with mean if normally distributed and by median if skewed

sns.distplot(df['volatile acidity'])
df['volatile acidity'].fillna(df['volatile acidity'].mean(),inplace=True)

sns.distplot(df['chlorides'])
df['chlorides'].fillna(df['chlorides'].mean(),inplace=True)

sns.distplot(df['free sulfur dioxide'])
df['free sulfur dioxide'].fillna(df['free sulfur dioxide'].median(),inplace=True)

sns.distplot(df['fixed acidity'])
df['fixed acidity'].fillna(df['fixed acidity'].mean(),inplace=True)

sns.distplot(df['citric acid'])
df['citric acid'].fillna(df['citric acid'].median(),inplace=True)

sns.distplot(df['residual sugar'])
df['residual sugar'].fillna(df['residual sugar'].median(),inplace=True)

sns.distplot(df['sulphates'])
df['sulphates'].fillna(df['sulphates'].mean(),inplace=True)

df.isna().sum()

#A Handling outliers
Q1 = df.quantile(0.25)
Q3 = df.quantile(0.75)
IQR = Q3 - Q1

outliers = ((df < (Q1 - 1.5 * IQR)) | (df > (Q3 + 1.5 * IQR))).any(axis=1)
df = df[~outliers]

#B Data Transformation-------------
def map_quality(quality):
    if quality >= 3 and quality <= 6:
        return 0
    elif quality >= 7 and quality <= 8:
        return 1
    else:
        return None
df['quality'] = df['quality'].apply(map_quality)

quality_distribution = df['quality'].value_counts()
print("Wine quality distribution:")
print(quality_distribution)

plt.figure(figsize=(8, 6))
quality_distribution.plot(kind='bar', color='blue')
plt.title('Wine Quality Distribution')
plt.xlabel('Quality')
plt.ylabel('Count')
plt.xticks(rotation=0)
plt.show()

#Encoding and balancing
# No encoding as there is no categorical columns
from imblearn.over_sampling import SMOTE
X = df.drop(columns=['quality'])
y = df['quality']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
smote = SMOTE(random_state=42)
X_train_resampled, y_train_resampled = smote.fit_resample(X_train, y_train)

selected_features = X.columns

#Model and metrics
from sklearn.metrics import classification_report
clf = RandomForestClassifier(random_state=42)
clf.fit(X_train_resampled, y_train_resampled)
y_pred = clf.predict(X_test)

accuracy = accuracy_score(y_test, y_pred)
print("Accuracy:", round(accuracy*100,2),"%")
prec = precision_score(y_test, y_pred)
print("Precision:", round(prec*100,2),"%")
recall = recall_score(y_test, y_pred)
print("Recall:", round(recall*100,2),"%")